---
title: "Gina's fish personality"
output: pdf_document
date: "2023-05-24"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Background information

This project evaluates the effect of BMAA (a cyanotoxin) on fathead minnow behavior. Young fish were grouped in 3 treatment conditions: control (no BMAA exposure), T5 (low BMAA exposure) and T25 (moderate BMAA exposure). Behavioral responses to an open-field test were then recorded at 8 time points across development. Ethovision was used to record behavior during the open-field test and resulted in many different variables that could represent different aspects of personality. Additionally, embryos were test once for burst activity.

Our main questions with these data are:
1. Are the behaviors recorded during the open field test reflective of underlying personality traits? To test this we will evaluate the repeatability of each behavior across the 8 time points.
2. How does BMAA exposure affect behavior in the open field test? To test this we will compare performance among treatment groups.


# Methods

We first need to determine the relationships among the variables recorded by Ethovision.

```{r variables}
etho = read.csv(url("https://raw.githubusercontent.com/ginalamka/Personality_BMAA/main/EthoData_updated.csv?token=GHSAT0AAAAAACB372QA37AYRBA76MHRCWXSZD7LT4Q"), header=T, sep=",", stringsAsFactors=F)
etho$Age[which(etho$Age == 15)]<-14

##How correlated are the variables?
#Create dataframe with just numeric/integer values
etho.corr = etho[,-c(1:7)]
etho.corr$MeanTimeZ2 = as.numeric(etho.corr$MeanTimeZ2)
etho.corr$LatencyZ2 = as.numeric(etho.corr$LatencyZ2)
etho.corr=etho.corr[-which(is.na(etho.corr$MeanTimeZ2)),] #There are some missing data that may need to be changed to ceiling values? For now, we will ignore those.


library(Hmisc)
library(corrplot)
#Dataframe should be a matrix. 
cor = rcorr(as.matrix(etho.corr))
corrplot(cor$r,type = "upper",p.mat=cor$P, sig.level=0.05, insig = "blank",diag=F) #lots of variables correlated to differing degrees


```


# PCA
```{r pca}
##Do correlated variables load on PCs to suggest personality axes?
#calc principal components
# pca <- prcomp(etho.corr, scale=TRUE)
# 
# #need to reverse the signs
# pca$rotation <- -1*pca$rotation
# 
# #calc total variance explained by each princ component
# pca$sdev^2/sum(pca$sdev^2) # first 5 PCs account for 72ish % of variance in data
# 
# #display principal components
# loadings = data.frame(pca$rotation[1:25,1:5]) #all 25 variables, first 5 PCs
# loadings = loadings[order(-abs(loadings$PC1), -abs(loadings$PC2), -abs(loadings$PC3), -abs(loadings$PC4), -abs(loadings$PC5)),]
# 
# #create biplot to visualize
# biplot(pca$x[, 1:2], pca$rotation[, 1:2], cex=1)

# for(i in unique(etho$Age)){
#   temp = etho[etho$Age==i,]
#   temp$MeanTimeZ2 = as.numeric(temp$MeanTimeZ2)
#   temp$LatencyZ2 = as.numeric(temp$LatencyZ2)
#   temp=temp[-which(is.na(temp$MeanTimeZ2)),]
#   pca_i <- prcomp(temp[,8:32], scale=TRUE)
#   pca_i$rotation <- -1*pca_i$rotation
#   var = data.frame(pca_i$sdev^2/sum(pca_i$sdev^2))
#   rot = data.frame(pca_i$rotation[1:25,1])
#   colnames(var) = i
#   colnames(rot) = i
#   if(i==21){
#     vars = var
#     rots = rot
#   } else{
#     vars = cbind(vars, var)
#     rots = cbind(rots, rot)
#   }
# }
# #Range of variance accounted for by PC1 is 25-31%
# #Range of PC2 is 16-25%
# vars$PC = row.names(vars)
# scree.plot = gather(vars, age, value, "21":"189",factor_key =F)
# ggplot(scree.plot, aes(x = as.numeric(PC), y = (value)*100, color = as.factor(age))) + 
#   theme_bw() +
#   geom_line() +
#   geom_hline(yintercept=4) #the amount of variance each variable would contribute if all contributed the same amount: 1/25*100
# 
# 
# ###do PC loadings stay the same across ages? Spaghetti plot:
# library(tidyr)
# library(ggplot2)
# rots$variables = row.names(rots)
# plot.data = gather(rots, age, value, "21":"189", factor_key = F)
# ggplot(plot.data, aes(x = as.numeric(age), y = abs(value), color = variables)) +
#   geom_line() +
#   theme_bw()
```

## Interpreting the loadings (From http://strata.uga.edu/8370/lecturenotes/principalComponents.html): 
Because the sum of the squares of all loadings for an individual principal component must sum to one, we can calculate what the loadings would be if all variables contributed equally to that principal component. Any variable that has a larger loading than this value contributes more than one variableâ€™s worth of information and would be regarded as an important contributor to that principal component.

We have 25 variables, the square root of the value if each variable contributed equally (1/25) is 0.2. So, variable loadings that are greater than 0.2 contribute a larger than expected amount to the PC.

### PC1 - fast vs slow-exploring
The following variables have large, negative loadings: MeanVel, TotDist, FreqTransZ2.Z1, Mean.Activ, Tot.Act, FreqTransZ1.Z2, Mean.Mobility, FreqZ2.
The following variables have large, positive loadings (and so have an opposite effect of PC1): VarTurnAngle, LatencyZ2, LatencyZ2360.

### PC2
Large, negative loadings: CumDur.Z1, CumDurZ1
Large, positive loadings: CumDur.Z2, CumDurZ2, MeanTimeZ2, MeanTimeZ2Zero, FreqZ2


## PC conclusions
The PC loadings are too diffuse and inconsistent across time points. We will move forward with candidate variables for 3 personality traits, chosen based on the correlation matrix.


```{r variables by age}

etho$Age[which(etho$Age == 15)]<-14

#### Variables that relate to arena size change with age
boxplot(TotDist ~ Age, data = etho)
boxplot(log(MeanMeander+1) ~ Age, data = etho)




```



## Variables:
1. Exploration = Cumulative duration in the center (percent) **"CumDur.Z2"**
*Not used:*
  *Angular Velocity. The relative turn angle / time difference ; degrees per second; can be + or -. Measures the speed of change in direction of     movement - used to assess turn bias or circular tendency and abnormalities of behavior. NOTE - turn angle is sensitive to small movements of      body points. if distance moved is very small, turn angle can get high, unrealistic values (additionally, consecutive turns can have high          values). To combat this, let's scale distance moved.*
    *- Relative turn angle is the signed angle of each turn. As such, when summary statistics are done, some of the angles cancel each other out         and it is hard/confusing to interpret these numbers. Relative turn angle informs the primary direction of turns individuals make (rather          than how many turns vs how straight is the path)*
    *- As such, we may consider using another variable like cumulative duration in the center (see boldness)*

2. Activity = Mobility. The percentage of pixel change between current sample and previous sample *detected in the subject only* ; ranges from 0 - 100%. NOTE - mobility depends on size of subject only, not on arena size. small fish results in small number of pixels that change, therefore small movements results in high change **"Mean.Mobility"**

3. Boldness = Latency to enter the center **"LatencyZ2360"**


# Repeatability Results

## Exploration
```{r turning angle rpt}
etho = read.csv("/Users/kelseymccune/Documents/GitHub/Personality_BMAA/EthoData_updated.csv", header=T, sep=",", stringsAsFactors=F)

#test fit of Gaussian distribution
library(ggpubr)
ggqqplot(log(abs(scale(etho$MeanAngVel, center = T, scale = T))))
shapiro.test(log(abs(scale(etho$MeanAngVel, center = T, scale = T))))

library(lme4)
ta1 = lmer(log(abs(scale(MeanAngVel, center = T, scale = T))) ~ Treatment + Age + (1|FishName) + (1|Clutch) + (1|Paternity), data = etho)
summary(ta1) #fit is singular because clutch random effect accounts for 0 variance
ggqqplot(ta1@u)
plot(ta1)

# Maybe MeanTurnAngle will fit better? Why do values range from -16 to +16? Description of this variable on pg. 63 of Manual pdf
# Do we have absolute or relative mean turn angle/angular velocity?
ta2 = lmer(log(abs(MeanTurnAngle)) ~ Treatment + Age + (1|FishName) + (1|Clutch) + (1|Paternity), data = etho)
summary(ta2)
ggqqplot(ta2@u)
plot(ta2)

```

### Rethinking exploration

The data for turning angle are summarized from Relative turning angle (where the sign of the turn is taken in to account). This means that mean of turning angle within a trial are not reflective of the number and degree of turns individuals make because turns in different directions cancel out.

We could use Variance in Turning Angle to illustrate the predictability with which an individual turns, but variance is also calculated based on the mean which does not have much significance for exploration. Large numbers mean that turning angle is very different from the mean, small numbers mean the turning angle is similar to the mean.

Alternatively, we could pick different variables. For one, we could say Duration in the Center is representative of exploration and Latency to enter the Center is representative of boldness. Or we could say Frequency of Zone Alterations is a measure of exploration (actually no because they could be crossing zones repeatedly in a very small amount of space). Although it could seem like another measure of activity, it is not very correlated with Mean Mobility (0.24). This variable does look like it varies by arena size, so we would need to account for that in some way - maybe include an offset for average body size at each age, or arena size.

```{r exploration alternatives}
library(ggplot2)
ggplot(etho[which(etho$Treatment == "0"),], aes(x = FishName, y = VarTurnAngle)) +
  #facet_wrap(~Treatment) +
  geom_boxplot() +
  theme_classic()
ggplot(etho[which(etho$Treatment == "0"),], aes(x = FishName, y = CumDur.Z2/100)) +
  #facet_wrap(~Treatment) +
  geom_boxplot() +
  theme_classic()
#one outlier individual in Control that crossed zones a lot
ggplot(etho[which(etho$Treatment == "0"),], aes(x = FishName, y = LatencyZ2360)) +
  #facet_wrap(~Treatment) +
  geom_boxplot() +
  theme_classic()
#the ceiling values could make it hard to fit these data


```

Time spent in the middle can be the proportion of time spent in the middle (out of trial time = 360 sec) or the actual number of seconds spent in the middle zone. It is difficult to find a well-fitting model family or transformation of the proportion data. Negative binomial fits well to the proportion data. A poisson model with an observation-level random effect fits well to the count data.

```{r exploration-cumulative duration in the middle}
etho = read.csv("/Users/kelseymccune/Documents/GitHub/Personality_BMAA/EthoData_updated.csv", header=T, sep=",", stringsAsFactors=F)
etho$trial.time = 360
etho$OLRE = seq_len(nrow(etho)) #column with observation-level random effect
etho$scale.age = scale(etho$Age, scale = T, center = T)
etho$FishName = as.factor(etho$FishName)
etho$Treatment = as.factor(etho$Treatment)

library(DHARMa)
library(lme4)

# I tried binomial, poisson and negative binomial. Negative binomial and Poisson with Observation-level random effect to account for overdispersion are the only models that passed all model assumption checks.
#Negative Binomial:
simulationOutput <- simulateResiduals(fittedModel = glmer.nb(round(CumDur.Z2) ~ Treatment + scale.age + Treatment*scale.age + (1|FishName) + (1|Clutch), data=etho, control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))), n=250) #add optimizer because otherwise it fails to converge with interaction term
# fit is singular with Paternity included

#Poisson with Observation-level random effect to account for overdispersion:
simulationOutput <- simulateResiduals(fittedModel = glmer(round(CumDur.Z2) ~ Treatment + scale.age + Treatment*scale.age + (1|FishName) + (1|OLRE), family = poisson, data=etho), n=500) #isSingular warning because of Paternity & Clutch

plot(simulationOutput$scaledResiduals) #Expect a flat distribution of the overall residuals, and uniformity in y direction if plotted against any predictor. 
testDispersion(simulationOutput) #if under- or over-dispersed, then p-value<0.05, but then check the dispersion parameter and try to determine what in the model could be the cause and address it there, also check for zero inflation.
#p.nb= 0.19, p.pois = 0.14 
testZeroInflation(simulationOutput) #compare expected vs observed zeros, not zero-inflated if p>0.05.
#p.nb < 0.01 (10% are zeros), p.pois = 0.88  
testUniformity(simulationOutput) #check for heteroscedasticity ("a systematic dependency of the dispersion / variance on another variable in the model" Hartig, https://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html), which is indicated if dots aren't on the red line and p<0.05.
#p.nb = 0.02, p.pois = 0.49
plot(simulationOutput)



#### Best fit is the Poisson regression on percent time in middle with the OLRE. ####


# Double check which variables to include in accordance with above simulation results:
b1 = glmer(round(CumDur.Z2) ~ Treatment + scale.age + Treatment*scale.age + (1|FishName) + (1|Clutch) + (1|Paternity) + (1|OLRE), family = poisson, data=etho, control=glmerControl(optimizer="bobyqa", #add optimizer because otherwise it fails to converge
                                 optCtrl=list(maxfun=2e5))) # full model
theta <- getME(b1, "theta")
diag.element <- getME(b1, "lower")==0
which(theta[diag.element]<3e-5)
#Fit is singular because of clutch and paternity

b2 = glmer(round(CumDur.Z2) ~ Treatment + scale.age + Treatment*scale.age + (1|FishName) + (1|OLRE), family = poisson, data=etho)
anova(b1,b2) # no difference, proceed with model 2 (results did not change with or without optimizer)

b3 = glmer(round(CumDur.Z2) ~ Treatment + scale.age + (1|FishName) + (1|OLRE), family = poisson, data=etho) # no interaction
anova(b2,b3) # b2 is a significantly better fit. Use b2 in rpt function.

#### rptR package for repeatability estimate
rptB = rpt(round(CumDur.Z2) ~ Treatment + scale.age + Treatment*scale.age + (1|FishName) + (1|OLRE), datatype = "Poisson", data=etho, grname = "FishName", nboot = 100, npermut = 100) # model fails to converge with the OLRE ðŸ¤¦
rptB


#### MCMCglmm instead of rptR for repeatability estimate
#https://juliengamartin.github.io/wam_tuto/mcmcglmm-1.html
#examples in the lit: https://doi.org/10.1007/s00265-019-2637-4 ; https://doi.org/10.1111/jeb.13701
library(MCMCglmm)
prior = list(R=list(R1=list(V=1,nu=0.002)), G=list(G1=list(V=1,nu=0.002))) #weak priors
mc1 = MCMCglmm(round(CumDur.Z2) ~ Treatment + scale.age + Treatment*scale.age, random = ~FishName, family = "poisson", data = etho,
               verbose=F, prior=prior, nitt=63000, thin=20, burnin=5000)
plot(mc1) #all chains look good
autocorr(mc1$Sol) #Did fixed effects converge? (<0.1)? 
autocorr(mc1$VCV)
repeata <- mc1$VCV[,"FishName"]/(mc1$VCV[,"FishName"]+mc1$VCV[,"units"]) #latent scale adjusted repeatability and its credible interval
mean(repeata) # Repeatability: 0.12
var(repeata) # 0.001
posterior.mode(repeata) # 0.12
HPDinterval(repeata, 0.95) # 0.06 - 0.19

##### permute the data so fish behavior is random to test the significance of 0.12 repeatability value #####
##### Takes a loooong time to run with 1000. 10 permutations takes ~10 min
results = rep(NA, 1000) 
for(i in 1:1000){
  tmp0 = data.frame("FishName" = etho$FishName[which(etho$Treatment=="0")], 
                    "Treatment"=etho$Treatment[which(etho$Treatment=="0")], 
                    "scale.age" = etho$scale.age[which(etho$Treatment=="0")], 
                    "CumDur.Z2" = sample(etho$CumDur.Z2[which(etho$Treatment=="0")],replace=F))
  tmp5 = data.frame("FishName" = etho$FishName[which(etho$Treatment=="5")], 
                    "Treatment"=etho$Treatment[which(etho$Treatment=="5")], 
                    "scale.age" = etho$scale.age[which(etho$Treatment=="5")],
                    "CumDur.Z2" = sample(etho$CumDur.Z2[which(etho$Treatment=="5")],replace=F))
  tmp25 = data.frame("FishName" = etho$FishName[which(etho$Treatment=="25")], 
                     "Treatment"=etho$Treatment[which(etho$Treatment=="25")], 
                     "scale.age" = etho$scale.age[which(etho$Treatment=="25")],
                     "CumDur.Z2" = sample(etho$CumDur.Z2[which(etho$Treatment=="25")],replace=F))
  tmp = rbind(tmp0,tmp5,tmp25)
  #tmp = data.frame("FishName" = etho$FishName,
    #               "Treatment" = etho$Treatment,
   #                "scale.age" = etho$scale.age,
     #              "CumDur.Z2" = sample(etho$CumDur.Z2, replace = F))
  m <- MCMCglmm(round(CumDur.Z2) ~ Treatment + scale.age + Treatment*scale.age, random = ~FishName, family = "poisson", data = tmp,
               verbose=F, prior=prior, nitt=63000, thin=20, burnin=5000)
  
  if(i==1){
    rpt <- m$VCV[,"FishName"]/(m$VCV[,"FishName"]+m$VCV[,"units"]) #latent scale adjusted repeatability and its credible interval from the model
  } else{
    rpt = c(rpt, m$VCV[,"FishName"]/(m$VCV[,"FishName"]+m$VCV[,"units"])) #building by row all of the posterior estimates from each iteration of the permutation
  }
  results[i] = mean(rpt) #average repeatability estimate from each iteration of the permutation
}

hist(results) # average repeatability estimate from each iteration of the permutation, which randomizes choices within reversals
abline(v=0.12,col="red")
sum(results > 0.12)/1000 # probability the repeatability estimate from our actual data is greater than the repeatability estimates generated from the permutations which randomized the data

permut.results = results #rbind line hashtagged out in above permutations
permut.bytrt = results #line 295-298 hashtagged out in above permutations

permut.results = data.frame(permut.results)
colnames(permut.results) = "Repeatability"
permut.bytrt = data.frame(permut.bytrt)
colnames(permut.bytrt) = "Repeatability"
permut.results$type = "combined"
permut.bytrt$type = "by treatment"
permut = rbind(permut.results, permut.bytrt)

library(ggplot2)
library(ggbreak)
p <- ggplot(permut.bytrt, aes(x = Repeatability)) +
  geom_histogram(binwidth = 0.0001)+
  #facet_wrap(~type)+
  geom_vline(xintercept = 0.12, color = "red") +
  theme_classic() 
p+scale_x_break(c(0.0021,0.12), scales = "free", ticklabels = 0.12)
## I cannot get this plot to look how I want it to. The point is that no matter whether we permute across all data or permute data within treatment, the observed repeatability value is way larger.
  

ggplot(etho[which(etho$Treatment == "0"),], aes(x = FishName, y = round(CumDur.Z2))) +
  #facet_wrap(~Treatment) +
  geom_boxplot() +
  theme_classic()

```

### Exploration and treatment effects
```{r exploration & treatment}
summary(mc1)
# Main effects of treatment and age are not significant.
# interaction between treatment 5 and age is significant at B = -0.23, p = 0.05

# plot to visualize interaction effect
ggplot(etho[!etho$Treatment == "25",], aes(x = Age, y = log(CumDur.Z2+1), color = Treatment))+
  geom_point() +
  geom_smooth(method = "lm") +
  theme_bw()

```
BMAA treatment was unrelated to the amount of time fish spent in the center of the arena. There was also no main effect of age. However, there was a significant interaction between treatment 5 and age. Relative to control fish, fish in the treatment 5 group decreased the duration they spent in the center over time.


## Boldness

Because of the relative turn angle, we need to use cumulative duration in the middle as our measure of exploration. We instead use latency to enter the middle as our measure of boldness.
```{r boldness-latency to enter the middle}
etho = read.csv("/Users/kelseymccune/Documents/GitHub/Personality_BMAA/EthoData_updated.csv", header=T, sep=",", stringsAsFactors=F)
etho$trial.time = 360
etho$OLRE = seq_len(nrow(etho)) #column with observation-level random effect
etho$scale.age = scale(etho$Age, scale = T, center = T)
etho$FishName = as.factor(etho$FishName)
etho$Treatment = as.factor(etho$Treatment)
etho$Age[which(etho$Age == "15")]<-"14"

#Use LatencyZ2360 - which gives a ceiling value to those fish that never entered the center (10% of data)

library(DHARMa)
library(lme4)

hist(etho$LatencyZ2360) # could be poisson
hist(log(etho$LatencyZ2360+1))

#Poisson 
simulationOutput <- simulateResiduals(fittedModel = glmer(round(LatencyZ2360) ~ Treatment + scale.age + Treatment*scale.age + (1|FishName) + (1|Clutch) + (1|Paternity), family = poisson, data=etho), n=500) 
#Negative binomial
simulationOutput <- simulateResiduals(fittedModel = glmer.nb(round(LatencyZ2360) ~ Treatment + scale.age + Treatment*scale.age + (1|FishName) + (1|Clutch) + (1|Paternity), data=etho), n=500)
#Gaussian
simulationOutput <- simulateResiduals(fittedModel = lmer(log(LatencyZ2360+1) ~ Treatment + scale.age + Treatment*scale.age + (1|FishName) + (1|Clutch) + (1|Paternity), data=etho), n=500)

plot(simulationOutput$scaledResiduals) #Expect a flat distribution of the overall residuals, and uniformity in y direction if plotted against any predictor. 
testDispersion(simulationOutput) #if under- or over-dispersed, then p-value<0.05, but then check the dispersion parameter and try to determine what in the model could be the cause and address it there, also check for zero inflation.
#p.nb= 0.03 (under-dispersed), p.pois = 0.63, p.gaus = 0.9 
testZeroInflation(simulationOutput) #compare expected vs observed zeros, not zero-inflated if p>0.05.
#p.nb=0.9, p.pois < 0.01, p.gaus < 0.01  (3% are zeros) ... something seems wrong here
testUniformity(simulationOutput) #check for heteroscedasticity ("a systematic dependency of the dispersion / variance on another variable in the model" Hartig, https://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html), which is indicated if dots aren't on the red line and p<0.05.
#p.nb= 0.04, p.pois < 0.01, p.gaus= 0.11
plot(simulationOutput)


l1 = lmer(log(LatencyZ2360+1) ~ Treatment + scale.age + Treatment*scale.age + (1|FishName) + (1|Clutch) + (1|Paternity), data=etho) #full model
l2 = lmer(log(LatencyZ2360+1) ~ Treatment + scale.age + Treatment*scale.age + (1|FishName) + (1|Clutch), data=etho)
anova(l1,l2) #no difference, use simpler model (l2)
VarCorr(l2) #Random effects and residual variance

l3 = lmer(log(LatencyZ2360+1) ~ Treatment + scale.age + Treatment*scale.age + (1|FishName), data=etho)
anova(l2,l3) #l2 is better

l4 = lmer(log(LatencyZ2360+1) ~ Treatment + scale.age + (1|FishName) + (1|Clutch), data=etho)
anova(l2,l4) #no difference, use simpler model (l4)

l5 = lmer(log(LatencyZ2360+1) ~ Treatment + scale.age + (1|Clutch), data=etho) # does FishName account for significant amount of variance?
anova(l5,l4) #actually model without FishName is better...


l.rpt = rpt(log(LatencyZ2360+1) ~ Treatment + scale.age + (1|FishName) + (1|Clutch), datatype = "Gaussian", data=etho, grname = "FishName", nboot = 500, npermut = 500) #singular fit warning with or without Clutch
l.rpt
# R = 0.07 (0.03-0.13)
# p.LRT and p.permute < 0.01

plot(l.rpt, type = "permut")

```
### Latency and survival models
It is straightforward to extract the random effect variance from the output of a coxme survival model. However, according to this post: https://stat.ethz.ch/pipermail/r-sig-mixed-models/2015q3/023871.html, there is no residual variance in Cox survival models. I can account for pseudocorrelation of repeated measures with coxph if I include FishName as a cluster or frailty term. But I can't seem to then get the amount of variance these terms account for.

### Boldness and treatment effects
```{r boldness & treatment}
library(car)

summary(l4) # need to calculate p-values
Anova(l4, test="F")

library(nlme)
l4.nlme = lme(log(LatencyZ2360+1) ~ Treatment + scale.age, random = list(~ 1|FishName,
                                                                         ~ 1|Clutch), data=etho)
summary(l4.nlme)
# no treatment effects. Significant Age effect suggesting habituation (as fish experienced more trials/got older, latency to enter the center decreased)
```
BMAA treatment was unrelated to the latency to enter the center (boldness). As individuals experience more trials, the latency to enter the ceter decreased, suggesting habituation to the experimental arena.



## Activity
Mobility is our measure of activity. This variable describes the percentage of pixel change between the current sample at the time (t) and previous sample (t-1) *this is detected in the subject only, not the full arena* (full arena pixel change aka "activity" described by EthoVision) ; ranges from 0 - 100%. Mobility depends on the size of subject only, not on the arena size; a small fish results in a small number of pixels that change, therefore small movements may result in high change.

Because we are not using variance in turning angle as a measure of exploration anymore, no need to include it as a covariate.
```{r activity- mobility}
etho = read.csv("/Users/kelseymccune/Documents/GitHub/Personality_BMAA/EthoData_updated.csv", header=T, sep=",", stringsAsFactors=F)
etho$FishName = as.factor(etho$FishName)
etho$Treatment = as.factor(etho$Treatment)
etho$Age[which(etho$Age == 15)]<-14
etho$Age = as.numeric(etho$Age)
etho$scale.age = scale(etho$Age, scale = T, center = T)

library(DHARMa)
library(lme4)
library(rptR)

hist(etho$Mean.Mobility) # looks good

#Gaussian
simulationOutput <- simulateResiduals(fittedModel = lmer(log(Mean.Mobility+1) ~ Treatment + scale.age + Treatment*scale.age + (1|FishName) + (1|Clutch) + (1|Paternity), data=etho), n=500)
#Poisson 
simulationOutput <- simulateResiduals(fittedModel = glmer(round(Mean.Mobility) ~ Treatment + scale.age + Treatment*scale.age + (1|FishName) + (1|Clutch) + (1|Paternity), family = poisson, data=etho), n=500) 

plot(simulationOutput$scaledResiduals) #Expect a flat distribution of the overall residuals, and uniformity in y direction if plotted against any predictor. 
testDispersion(simulationOutput) #if under- or over-dispersed, then p-value<0.05, but then check the dispersion parameter and try to determine what in the model could be the cause and address it there, also check for zero inflation.
#p.g = 0.94 , p.p < 0.01
testZeroInflation(simulationOutput) #compare expected vs observed zeros, not zero-inflated if p>0.05.
#p.g = 1 , p.p = 0.79
testUniformity(simulationOutput) #check for heteroscedasticity ("a systematic dependency of the dispersion / variance on another variable in the model" Hartig, https://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html), which is indicated if dots aren't on the red line and p<0.05.
#p.g < 0.01 , p.p < 0.01

#the log(Mean.Mobility+1) brings the uniformity p-val = 0.0445 (from 6.848e-08). Going with log
plot(simulationOutput)

m1 = lmer(log(Mean.Mobility+1) ~ Treatment + scale.age + Treatment*scale.age + (1|FishName) + (1|Clutch) + (1|Paternity), data=etho) #full model
m2 = lmer(log(Mean.Mobility+1) ~ Treatment + scale.age + Treatment*scale.age + (1|FishName) + (1|Clutch), data=etho)
anova(m1,m2) #no difference, use simpler model (m2)

m3 = lmer(log(Mean.Mobility+1) ~ Treatment + scale.age + Treatment*scale.age + (1|FishName), data=etho)
anova(m2,m3) #m2 is better

m4 = lmer(log(Mean.Mobility+1) ~ Treatment + scale.age + (1|FishName) + (1|Clutch), data=etho)
anova(m2,m4) #no difference, use simpler model (m4)

m5 = lmer(log(Mean.Mobility+1) ~ Treatment + scale.age + (1|Clutch), data=etho) # does FishName account for significant amount of variance?
anova(m5,m4) #m4 is better - accounts for somethin!

m6 = lmer(log(Mean.Mobility+1) ~ Treatment + scale.age + (1|FishName), data=etho) # does Clutch account for significant amount of variance?
anova(m4,m6) #m4 is better - accounts for somethin!


m.rpt = rpt(Mean.Mobility ~ Treatment + scale.age + (1|FishName) + (1|Clutch), datatype = "Gaussian", data=etho, grname = c("FishName","Clutch"), nboot = 500, npermut = 500) #singular fit warning with or without Clutch
m.rpt
# R = 0.13 (0.07-0.18)
# p.LRT and p.permute < 0.01

plot(m.rpt, type = "permut")

theta <- getME(m4, "theta")
diag.element <- getME(m4, "lower")==0
which(theta[diag.element]<1e-5) #looks like clutch and fishname are important

```

### Activity and treatment effects
```{r activity & treatment}
summary(m4)

library(nlme)
m4.nlme = lme(log(Mean.Mobility+1) ~ Treatment + scale.age, random = list(~1|FishName, 
                                                                          ~1|Clutch), data=etho)
summary(m4.nlme)
# All fixed effects are significant. 
## Treatment5 B = -0.13, p = 0.03: Compared to control fish, treatment 5 fish are significantly less active
## Treatment25 B = 0.11, p = 0.05; Compared to treatment 5 fish, treatment 25 fish are significantly more active
## Age B = -0.10, p = 0; As age/trial number increases, activity level decreases


# plot to visualize treatment effect
ggplot(etho, aes(x = Age, y = log(Mean.Mobility+1), color = Treatment))+
  geom_point() +
  geom_smooth(method = "lm") +
  theme_bw()
```
Treatment significantly relates to activity level, but the relationship varies by amount of treatment.



## Why are repeatability values so low?

```{r repeatability by treatment group}
#Cumulative duration in the center
ggplot(etho, aes(x = reorder(FishName,CumDur.Z2,mean), y = log(CumDur.Z2+1), color = Treatment)) +
  facet_wrap(~Treatment) +
  geom_boxplot() +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank())

ggplot(etho, aes(x = as.factor(as.numeric(Age)), y = log(CumDur.Z2+1), color = Treatment)) +
  geom_boxplot() +
  theme_classic()

#Latency to enter the center
ggplot(etho, aes(x = reorder(FishName,LatencyZ2360,mean), y = LatencyZ2360, color = Treatment)) +
  facet_wrap(~Treatment) +
  geom_boxplot() +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank())

ggplot(etho, aes(x = as.factor(as.numeric(Age)), y = LatencyZ2360, color = Treatment)) +
  geom_boxplot() +
  theme_classic()

#Mobility
ggplot(etho, aes(x = reorder(FishName,Mean.Mobility,mean), y = log(Mean.Mobility+1), color = Treatment)) +
  facet_wrap(~Treatment) +
  geom_boxplot() +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank())

ggplot(etho, aes(x = as.factor(as.numeric(Age)), y = log(Mean.Mobility+1), color = Treatment)) +
  geom_boxplot() +
  theme_classic()

##Distribution of values look similar across groups
```



## Behavioral Syndromes
Using the tutorial/supplemental material from Houslay & Wilson 2017: Avoiding the misuse of BLUP in behavioral ecology https://tomhouslay.files.wordpress.com/2017/02/indivvar_mv_tutorial_mcmcglmm.pdf
```{r behav syndrome}
etho = read.csv("/Users/kelseymccune/Documents/GitHub/Personality_BMAA/EthoData_updated.csv", header=T, sep=",", stringsAsFactors=F)
etho$FishName = as.factor(etho$FishName)
etho$Treatment = as.factor(etho$Treatment)
etho$Age[which(etho$Age == 15)]<-14
etho$Age = as.numeric(etho$Age)
etho$scale.age = scale(etho$Age, scale = T, center = T)

library(MCMCglmm)

#uninformative prior for a model with 3 DVs, one random effect and two fixed effects
prior_mltvar = list(R = list(V = diag(3), nu = 1.002),
            G = list(G1 = list(V = diag(3), nu = 3,
            alpha.mu = rep(0,3),
            alpha.V = diag(25^2,3,3))))

#multivariate model for our 3 variables (Mean.Mobility, round(CumDur.Z2), log(LatencyZ2360+1)
mlt.var = MCMCglmm(cbind(Mean.Mobility, round(CumDur.Z2), log(LatencyZ2360+1)) ~ trait-1 +
            trait:scale.age +
            trait:Treatment,
            random =~ us(trait):FishName,
            rcov =~ us(trait):units,
            family = c("gaussian","poisson","gaussian"),
            prior = prior_mltvar,
            nitt=420000,
            burnin=8000,
            thin=100,
            verbose = TRUE,
            data = etho)

plot(mlt.var) # all looks pretty good
autocorr(mlt.var$Sol) # converged
autocorr(mlt.var$VCV) # converged
summary(mlt.var) # G-structure is DV variance and co-variances

# Checking that repeatability estimates are similar:
## Mean.Mobility
rpt.mob <- mlt.var$VCV[,"traitMean.Mobility:traitMean.Mobility.FishName"]/(    # between individual variation
mlt.var$VCV[,"traitMean.Mobility:traitMean.Mobility.FishName"] + 
mlt.var$VCV[,"traitMean.Mobility:traitMean.Mobility.units"]   #between individual variation + Residual variation
)
mean(rpt.mob) # 0.16 (higher than rpt)
HPDinterval(rpt.mob) # 0.11-0.22
plot(rpt.mob)

## CumDur.Z2
rpt.dur <- mlt.var$VCV[,"traitCumDur.Z2:traitCumDur.Z2.FishName"]/(    # between individual variation
mlt.var$VCV[,"traitCumDur.Z2:traitCumDur.Z2.FishName"] + 
mlt.var$VCV[,"traitCumDur.Z2:traitCumDur.Z2.units"]   #between individual variation + Residual variation
)
mean(rpt.dur) # 0.12 (the same as MCMCglmm above)
HPDinterval(rpt.dur) # 0.06-0.18
plot(rpt.dur)

## LatencyZ2360
rpt.lat <- mlt.var$VCV[,"traitLatencyZ2360:traitLatencyZ2360.FishName"]/(    # between individual variation
mlt.var$VCV[,"traitLatencyZ2360:traitLatencyZ2360.FishName"] + 
mlt.var$VCV[,"traitLatencyZ2360:traitLatencyZ2360.units"]   #between individual variation + Residual variation
)
mean(rpt.lat) # 0.11 (higher than rpt)
HPDinterval(rpt.lat) # 0.06-0.16
plot(rpt.lat)


# Correlations between 2 traits
## Mobility/Duration
cor_MobDur <- mlt.var$VCV[,"traitMean.Mobility:traitCumDur.Z2.FishName"]/
(sqrt(mlt.var$VCV[,"traitMean.Mobility:traitMean.Mobility.FishName"])*
sqrt(mlt.var$VCV[,"traitCumDur.Z2:traitCumDur.Z2.FishName"]))
mean(cor_MobDur) # 0.09
HPDinterval(cor_MobDur) # -0.23-0.43 ...crosses zero so non-significant correlation
plot(cor_MobDur)

## Mobility/Latency
cor_MobLat <- mlt.var$VCV[,"traitMean.Mobility:traitLatencyZ2360.FishName"]/
(sqrt(mlt.var$VCV[,"traitMean.Mobility:traitMean.Mobility.FishName"])*
sqrt(mlt.var$VCV[,"traitLatencyZ2360:traitLatencyZ2360.FishName"]))
mean(cor_MobLat) # -0.77
HPDinterval(cor_MobLat) # -0.96 - -0.60 ...does NOT cross zero, so significant correlation
plot(cor_MobLat)

## Latency/Duration
cor_LatDur <- mlt.var$VCV[,"traitLatencyZ2360:traitCumDur.Z2.FishName"]/
(sqrt(mlt.var$VCV[,"traitLatencyZ2360:traitLatencyZ2360.FishName"])*
sqrt(mlt.var$VCV[,"traitCumDur.Z2:traitCumDur.Z2.FishName"]))
mean(cor_LatDur) # -0.34
HPDinterval(cor_LatDur) # -0.65 - -0.02 ...does NOT cross zero, so significant correlation
plot(cor_LatDur)


# Visualizing
## Correlation plot
df_cors <- data.frame(Traits = c("Activity,Exploration",
                                 "Activity,Boldness",
                                 "Boldness, Exploration"),
                      Estimate = c(mean(cor_MobDur),
                                   mean(cor_MobLat),
                                   mean(cor_LatDur)),
                      Lower = c(HPDinterval(cor_MobDur)[,"lower"],
                                HPDinterval(cor_MobLat)[,"lower"],
                                HPDinterval(cor_LatDur)[,"lower"]),
                      Upper = c(HPDinterval(cor_MobDur)[,"upper"],
                                HPDinterval(cor_MobLat)[,"upper"],
                                HPDinterval(cor_LatDur)[,"upper"]))

ggplot(df_cors, aes(x = Traits, y = Estimate)) +
       geom_pointrange(aes(ymin = Lower, ymax = Upper)) +
       geom_hline(yintercept = 0, linetype = "dotted", alpha = 0.3) +
       scale_x_discrete(limits = c("Activity,Exploration","Activity,Boldness","Boldness, Exploration")) +
       labs(x = "Trait combinations",y = "Correlation (Estimate +/- 95% CIs)") +
       ylim(-1,1) + coord_flip() +
       theme_classic()


```

Boldness and exploration are negatively correlated, but that has to do with the fact that boldness is quantified as a latency. More exploratory individuals (spent more time in the center), had lower latencies to enter the center (i.e. more bold). Similarly, more active individuals had shorter latencies to enter the center. The propensity to show higher activity was not significantly correlated with the amount of time spent in the center.

### Do behavioral syndromes vary by treatment level?
```{r BS by treatment}
library(MCMCglmm)

# 3 separate multivariate models for contol, treatment 5 and treatment 25:
##uninformative prior for a model with 3 DVs, one random effect and one fixed effects
prior_mltvar = list(R = list(V = diag(3), nu = 1.002),
            G = list(G1 = list(V = diag(3), nu = 3,
            alpha.mu = rep(0,3),
            alpha.V = diag(25^2,3,3))))

t0.bs = MCMCglmm(cbind(Mean.Mobility, round(CumDur.Z2), log(LatencyZ2360+1)) ~ trait-1 +
            trait:scale.age,
            random =~ us(trait):FishName,
            rcov =~ us(trait):units,
            family = c("gaussian","poisson","gaussian"),
            prior = prior_mltvar,
            nitt=420000,
            burnin=8000,
            thin=100,
            verbose = TRUE,
            data = etho[which(etho$Treatment == "0"),])

t5.bs = MCMCglmm(cbind(Mean.Mobility, round(CumDur.Z2), log(LatencyZ2360+1)) ~ trait-1 +
            trait:scale.age,
            random =~ us(trait):FishName,
            rcov =~ us(trait):units,
            family = c("gaussian","poisson","gaussian"),
            prior = prior_mltvar,
            nitt=420000,
            burnin=8000,
            thin=100,
            verbose = TRUE,
            data = etho[which(etho$Treatment == "5"),])

t25.bs = MCMCglmm(cbind(Mean.Mobility, round(CumDur.Z2), log(LatencyZ2360+1)) ~ trait-1 +
            trait:scale.age,
            random =~ us(trait):FishName,
            rcov =~ us(trait):units,
            family = c("gaussian","poisson","gaussian"),
            prior = prior_mltvar,
            nitt=420000,
            burnin=800,
            thin=100,
            verbose = TRUE,
            data = etho[which(etho$Treatment == "25"),])

# From the variance components of the modles calculate the correlation among individuals for each pair of variables in each treatment group
## Control (T0)
### Mobility/Duration
t0.cor_MobDur <- t0.bs$VCV[,"traitMean.Mobility:traitCumDur.Z2.FishName"]/
(sqrt(t0.bs$VCV[,"traitMean.Mobility:traitMean.Mobility.FishName"])*
sqrt(t0.bs$VCV[,"traitCumDur.Z2:traitCumDur.Z2.FishName"]))
### Mobility/Latency
t0.cor_MobLat <- t0.bs$VCV[,"traitMean.Mobility:traitLatencyZ2360.FishName"]/
(sqrt(t0.bs$VCV[,"traitMean.Mobility:traitMean.Mobility.FishName"])*
sqrt(t0.bs$VCV[,"traitLatencyZ2360:traitLatencyZ2360.FishName"]))
### Latency/Duration
t0.cor_LatDur <- t0.bs$VCV[,"traitLatencyZ2360:traitCumDur.Z2.FishName"]/
(sqrt(t0.bs$VCV[,"traitLatencyZ2360:traitLatencyZ2360.FishName"])*
sqrt(t0.bs$VCV[,"traitCumDur.Z2:traitCumDur.Z2.FishName"]))

## Treatment 5 (T5)
### Mobility/Duration
t5.cor_MobDur <- t5.bs$VCV[,"traitMean.Mobility:traitCumDur.Z2.FishName"]/
(sqrt(t5.bs$VCV[,"traitMean.Mobility:traitMean.Mobility.FishName"])*
sqrt(t5.bs$VCV[,"traitCumDur.Z2:traitCumDur.Z2.FishName"]))
### Mobility/Latency
t5.cor_MobLat <- t5.bs$VCV[,"traitMean.Mobility:traitLatencyZ2360.FishName"]/
(sqrt(t5.bs$VCV[,"traitMean.Mobility:traitMean.Mobility.FishName"])*
sqrt(t5.bs$VCV[,"traitLatencyZ2360:traitLatencyZ2360.FishName"]))
### Latency/Duration
t5.cor_LatDur <- t5.bs$VCV[,"traitLatencyZ2360:traitCumDur.Z2.FishName"]/
(sqrt(t5.bs$VCV[,"traitLatencyZ2360:traitLatencyZ2360.FishName"])*
sqrt(t5.bs$VCV[,"traitCumDur.Z2:traitCumDur.Z2.FishName"]))

## Treatment 25 (T25)
### Mobility/Duration
t25.cor_MobDur <- t25.bs$VCV[,"traitMean.Mobility:traitCumDur.Z2.FishName"]/
(sqrt(t25.bs$VCV[,"traitMean.Mobility:traitMean.Mobility.FishName"])*
sqrt(t25.bs$VCV[,"traitCumDur.Z2:traitCumDur.Z2.FishName"]))
### Mobility/Latency
t25.cor_MobLat <- t25.bs$VCV[,"traitMean.Mobility:traitLatencyZ2360.FishName"]/
(sqrt(t25.bs$VCV[,"traitMean.Mobility:traitMean.Mobility.FishName"])*
sqrt(t25.bs$VCV[,"traitLatencyZ2360:traitLatencyZ2360.FishName"]))
### Latency/Duration
t25.cor_LatDur <- t25.bs$VCV[,"traitLatencyZ2360:traitCumDur.Z2.FishName"]/
(sqrt(t25.bs$VCV[,"traitLatencyZ2360:traitLatencyZ2360.FishName"])*
sqrt(t25.bs$VCV[,"traitCumDur.Z2:traitCumDur.Z2.FishName"]))


# Visualizing
## Correlation plot
t.df_cors <- data.frame(Traits = c("Activity,Exploration","Activity,Exploration","Activity,Exploration",
                                 "Activity,Boldness","Activity,Boldness","Activity,Boldness",
                                 "Boldness, Exploration","Boldness, Exploration","Boldness, Exploration"),
                      Treatment = c("Control","T5","T25",
                                    "Control","T5","T25",
                                    "Control","T5","T25"),  
                      Estimate = c(mean(t0.cor_MobDur),mean(t5.cor_MobDur),mean(t25.cor_MobDur),
                                   mean(t0.cor_MobLat),mean(t5.cor_MobLat),mean(t25.cor_MobLat),
                                   mean(t0.cor_LatDur),mean(t5.cor_LatDur),mean(t25.cor_LatDur)),
                      Lower = c(HPDinterval(t0.cor_MobDur)[,"lower"],HPDinterval(t5.cor_MobDur)[,"lower"],HPDinterval(t25.cor_MobDur)[,"lower"],
                                HPDinterval(t0.cor_MobLat)[,"lower"],HPDinterval(t5.cor_MobLat)[,"lower"],HPDinterval(t25.cor_MobLat)[,"lower"],
                                HPDinterval(t0.cor_LatDur)[,"lower"],HPDinterval(t5.cor_LatDur)[,"lower"],HPDinterval(t25.cor_LatDur)[,"lower"]),
                      Upper = c(HPDinterval(t0.cor_MobDur)[,"upper"],HPDinterval(t5.cor_MobDur)[,"upper"],HPDinterval(t25.cor_MobDur)[,"upper"],
                                HPDinterval(t0.cor_MobLat)[,"upper"],HPDinterval(t5.cor_MobLat)[,"upper"],HPDinterval(t25.cor_MobLat)[,"upper"],
                                HPDinterval(t0.cor_LatDur)[,"upper"],HPDinterval(t5.cor_LatDur)[,"upper"],HPDinterval(t25.cor_LatDur)[,"upper"]))

ggplot(t.df_cors, aes(x = Traits, y = Estimate, color = Treatment)) +
       geom_pointrange(aes(ymin = Lower, ymax = Upper),position=position_dodge(width=0.5)) +
       geom_hline(yintercept = 0, linetype = "dotted", alpha = 0.3) +
       scale_x_discrete(limits = c("Activity,Exploration","Activity,Boldness","Boldness, Exploration")) +
       labs(x = "Trait combinations",y = "Correlation (Estimate +/- 95% CIs)") +
       ylim(-1,1) + coord_flip() +
       theme_classic()

```
No difference in behavioral syndromes by Treatment because all 95% CIs overlap among the treatment groups. However, the decreased sample size led to the boldness:exploration correlation becoming statistically nonsignificant.



